const bitrix = require('./bitrixClient');
const axios = require('axios');
const fs = require('fs');
const fsp = require('fs/promises');
const path = require('path');
const os = require('os');
const unzipper = require('unzipper');
const cfg = require('../../config/spa1048');


const { logDebug, logInfo, logWarn, logError, serializeError } = require('../../utils/logger');
// –í crm.item.get UF-—Ñ–∞–π–ª—ã –ø—Ä–∏—Ö–æ–¥—è—Ç –≤ camelCase:
const F_FILES_PAY_READ = process.env.SPA1048_FILES_FIELD_PAY_CAMEL || 'ufCrm8_1768219060503';
// –î–ª—è update –Ω–∞–¥—ë–∂–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è:
const F_FILES_PAY_WRITE = process.env.SPA1048_FILES_FIELD_PAY_ORIG || process.env.SPA1048_FILES_FIELD_PAY_CAMEL || 'ufCrm8_1768219060503';

const ZIP_MAX_FILES = Number(process.env.SPA1048_ZIP_MAX_FILES || 200);
const ZIP_MAX_PDF_MB = Number(process.env.SPA1048_ZIP_MAX_PDF_MB || 15);
const ZIP_DEBUG = process.env.SPA1048_DEBUG_ZIP === '1';
function logZip(tag, obj){ if (ZIP_DEBUG) console.log('[spa1048][zip]', tag, JSON.stringify(obj||{})); }

const ZIP_CHUNK = Number(process.env.SPA1048_ZIP_CHUNK || 4);
const FILE_URL_TTL_MS = Number(process.env.SPA1048_FILE_URL_TTL_MS || 6 * 60 * 60 * 1000);

function unwrap(resp) {
  return resp?.result ?? resp;
}

// backward-compat: old code paths may call detectRemoteKind()
async function detectRemoteKind(){ return 'unknown'; }

function normalizeStageId(x) {
  if (!x) return '';
  return String(x).trim().replace(/^['"]+|['"]+$/g, '');
}

function nowIso() {
  return new Date().toISOString();
}

function marker(fileId) {
  return `[file:${fileId}]`;
}

function extractMarkerId(title) {
  const m = String(title || '').match(/\[file:(\d+)\]\s*$/);
  return m ? m[1] : null;
}

function fileNameFromContentDisposition(cd) {
  if (!cd) return null;
  const s = String(cd);

  // RFC 5987: filename*=UTF-8''...
  const m1 = s.match(/filename\*\s*=\s*([^;]+)/i);
  if (m1) {
    let v = m1[1].trim();
    v = v.replace(/^UTF-8''/i, '');
    v = v.replace(/^["']|["']$/g, '');
    try { return decodeURIComponent(v); } catch (_e) { return v; }
  }

  // filename="..."
  const m2 = s.match(/filename\s*=\s*("?)([^";]+)\1/i);
  if (m2) return m2[2].trim();

  return null;
}

function fileNameFromFileObject(fileObjOrId) {
  if (!fileObjOrId || typeof fileObjOrId !== 'object') return null;
  const candidates = [
    fileObjOrId.name,
    fileObjOrId.NAME,
    fileObjOrId.fileName,
    fileObjOrId.FILE_NAME,
    fileObjOrId.originalName,
    fileObjOrId.ORIGINAL_NAME,
    fileObjOrId.file_name,
  ];
  const hit = candidates.find((x) => typeof x === 'string' && x.trim());
  return hit ? String(hit).trim() : null;
}

function extractFileUrl(fileObjOrId) {
  if (!fileObjOrId || typeof fileObjOrId !== 'object') return null;
  const candidates = [
    fileObjOrId.urlMachine,
    fileObjOrId.url_machine,
    fileObjOrId.url,
    fileObjOrId.downloadUrl,
    fileObjOrId.DOWNLOAD_URL,
  ];
  return candidates.find((x) => typeof x === 'string' && x.trim()) || null;
}

function findFileObjectById(fileId, files) {
  if (!fileId || !Array.isArray(files)) return null;
  const id = String(fileId);
  return files.find((f) => String(normalizeFileToken(f) || '') === id) || null;
}

const _fileUrlCache = new Map(); // fileId -> { url, ts }

async function resolveFileUrl(fileObjOrId, { files } = {}) {
  const fileId = normalizeFileToken(fileObjOrId);
  if (!fileId) return null;

  const direct = extractFileUrl(fileObjOrId);
  if (direct) return direct;

  const fromList = extractFileUrl(findFileObjectById(fileId, files));
  if (fromList) return fromList;

  const cached = _fileUrlCache.get(String(fileId));
  const now = Date.now();
  if (cached && (now - cached.ts) < FILE_URL_TTL_MS) return cached.url;

  try {
    const r = await bitrix.call('disk.file.get', { id: Number(fileId) });
    const data = r?.result || r?.file || r;
    const url = data?.DOWNLOAD_URL || data?.downloadUrl || data?.URL || data?.url;
    if (url) {
      _fileUrlCache.set(String(fileId), { url, ts: now });
      return url;
    }
  } catch (_e) {}

  return null;
}

function normalizeFileToken(x) {
  if (x == null) return null;
  if (typeof x === 'number') return String(x);
  if (typeof x === 'string') {
    const s = x.trim();
    const m = s.match(/(\d+)/);
    return m ? m[1] : null;
  }
  if (typeof x === 'object') {
    if (x.id != null) return normalizeFileToken(x.id);
    if (x.ID != null) return normalizeFileToken(x.ID);
    if (x.fileId != null) return normalizeFileToken(x.fileId);
    if (x.FILE_ID != null) return normalizeFileToken(x.FILE_ID);
    if (x.attachedId != null) return normalizeFileToken(x.attachedId);
  }
  return null;
}

function extractFilesList(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value;
  return [value];
}

async function resolveFileName(fileObjOrId) {
  const fileId = normalizeFileToken(fileObjOrId);
  if (!fileId) return null;

  const nameFromObj = fileNameFromFileObject(fileObjOrId);
  if (nameFromObj) return nameFromObj;

  const urlMachine =
    (fileObjOrId && typeof fileObjOrId === 'object')
      ? (extractFileUrl(fileObjOrId) || await resolveFileUrl(fileObjOrId))
      : null;

  if (urlMachine) {
    try {
      // HEAD —á–∞—Å—Ç–æ –∑–∞–ø—Ä–µ—â—ë–Ω ‚Äî fallback –Ω–∞ GET Range
      let resp = null;
      try {
        resp = await axios.head(urlMachine, { maxRedirects: 5, timeout: 20000, validateStatus: () => true });
      } catch (_e) {}

      if (!resp || resp.status >= 400) {
        resp = await axios.get(urlMachine, {
          headers: { Range: 'bytes=0-0' },
          responseType: 'arraybuffer',
          maxRedirects: 5,
          timeout: 20000,
          validateStatus: () => true,
        });
      }

      const cd = resp?.headers?.['content-disposition'] || resp?.headers?.['Content-Disposition'];
      const name = fileNameFromContentDisposition(cd);
      if (name) return String(name);

      const finalUrl = resp?.request?.res?.responseUrl;
      if (finalUrl) {
        const tail = String(finalUrl).split('?')[0].split('/').pop();
        if (tail && tail.includes('.')) return decodeURIComponent(tail);
      }
    } catch (_e2) {}
  }

  return `–§–∞–π–ª #${fileId}`;
}

function isZipName(name) {
  return /\.zip$/i.test(String(name || ''));
}

function isPdfName(name) {
  return /\.pdf$/i.test(String(name || ''));
}

// –ò–Ω–æ–≥–¥–∞ –≤ CRM file UF-–ø–æ–ª—è—Ö Bitrix24 –≤ –æ—Ç–≤–µ—Ç–µ –ø—Ä–∏—Ö–æ–¥—è—Ç —Ç–æ–ª—å–∫–æ id/url,
// –±–µ–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞. –ü–æ—ç—Ç–æ–º—É ZIP/PDF –ª—É—á—à–µ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –Ω–µ –ø–æ –∏–º–µ–Ω–∏, –∞ –ø–æ "–º–∞–≥–∏–∏".
// –î–µ–ª–∞–µ–º –ª—ë–≥–∫–∏–π –∑–∞–ø—Ä–æ—Å —Å Range, —á—Ç–æ–±—ã –Ω–µ –∫–∞—á–∞—Ç—å –≤–µ—Å—å —Ñ–∞–π–ª.
const _kindCache = new Map(); // fileId -> { kind: 'zip'|'pdf'|'other', ts }

function _bufHex(buf, n) {
  const b = Buffer.isBuffer(buf) ? buf : Buffer.from(buf || '');
  return b.subarray(0, n).toString('hex');
}

function _kindByMagic(buf) {
  const b = Buffer.isBuffer(buf) ? buf : Buffer.from(buf || '');
  if (b.length >= 4 && b[0] === 0x50 && b[1] === 0x4b) return 'zip'; // PK..
  // %PDF-
  if (b.length >= 5 && b[0] === 0x25 && b[1] === 0x50 && b[2] === 0x44 && b[3] === 0x46 && b[4] === 0x2d) return 'pdf';
  return 'other';
}

async function sniffRemoteKind(fileObj) {
  const fid = normalizeFileToken(fileObj);
  const url = await resolveFileUrl(fileObj);
  if (!fid || !url) return { kind: 'other', magic: '' };

  const cached = _kindCache.get(String(fid));
  const now = Date.now();
  if (cached && (now - cached.ts) < 6 * 60 * 60 * 1000) {
    return { kind: cached.kind, magic: cached.magic || '' };
  }

  // Bitrix –∏–Ω–æ–≥–¥–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Range, –ø–æ—ç—Ç–æ–º—É –¥–µ–ª–∞–µ–º fallback –Ω–∞ –ø–æ–ª–Ω—ã–π GET,
  // –Ω–æ –ª–∏–º–∏—Ç–∏—Ä—É–µ–º –æ–±—ä—ë–º —á–µ—Ä–µ–∑ maxContentLength.
  let head;
  try {
    const r = await axios.get(url, {
      responseType: 'arraybuffer',
      headers: { Range: 'bytes=0-31' },
      maxContentLength: 64 * 1024,
      maxBodyLength: 64 * 1024,
      timeout: 30000,
      validateStatus: (s) => s >= 200 && s < 400,
    });
    head = Buffer.from(r.data || []);
  } catch (e) {
    try {
      const r = await axios.get(url, {
        responseType: 'arraybuffer',
        maxContentLength: 64 * 1024,
        maxBodyLength: 64 * 1024,
        timeout: 30000,
        validateStatus: (s) => s >= 200 && s < 400,
      });
      head = Buffer.from(r.data || []);
    } catch (e2) {
      // –Ω–µ —Å–º–æ–≥–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ‚Äî —Å—á–∏—Ç–∞–µ–º other
      const magic = '';
      _kindCache.set(String(fid), { kind: 'other', ts: now, magic });
      return { kind: 'other', magic };
    }
  }

  const kind = _kindByMagic(head);
  const magic = _bufHex(head, 8);
  _kindCache.set(String(fid), { kind, ts: now, magic });
  return { kind, magic };
}

async function isPdfMagicOnDisk(fp) {
  try {
    const fd = await fsp.open(fp, 'r');
    try {
      const buf = Buffer.alloc(5);
      const { bytesRead } = await fd.read(buf, 0, 5, 0);
      if (bytesRead < 5) return false;
      return buf[0] === 0x25 && buf[1] === 0x50 && buf[2] === 0x44 && buf[3] === 0x46 && buf[4] === 0x2d;
    } finally {
      await fd.close();
    }
  } catch (_) {
    return false;
  }
}

async function buildChecklistTitle(fileName, fileId) {
  return `üßæ ${fileName} ${marker(fileId)}`;
}

async function listChecklist(taskId) {
  const r = await bitrix.call('task.checklistitem.getlist', {
    TASKID: Number(taskId),
    ORDER: { ID: 'ASC' },
  });
  const u = unwrap(r);
  return Array.isArray(u) ? u : (Array.isArray(u?.items) ? u.items : []);
}

async function addChecklistItem(taskId, title) {
  return unwrap(await bitrix.call('task.checklistitem.add', {
    TASKID: Number(taskId),
    FIELDS: { TITLE: title, IS_COMPLETE: 'N' },
  }));
}

async function updateChecklistItem(taskId, itemId, title) {
  return unwrap(await bitrix.call('task.checklistitem.update', {
    TASKID: Number(taskId),
    ITEMID: Number(itemId),
    FIELDS: { TITLE: title },
  }));
}

async function deleteChecklistItem(taskId, itemId) {
  return unwrap(await bitrix.call('task.checklistitem.delete', {
    TASKID: Number(taskId),
    ITEMID: Number(itemId),
  }));
}

async function addSpaTimelineComment(itemId, text) {
  return { ok: true, skipped: true };
  return { ok: true, skipped: true };
  const et = Number(cfg.entityTypeId);
  const id = Number(itemId);

  const tries = [
    {
      method: 'crm.timeline.comment.add',
      params: { fields: { ENTITY_TYPE_ID: et, ENTITY_ID: id, COMMENT: text } },
    },
    {
      method: 'crm.timeline.comment.add',
      params: { fields: { ENTITY_TYPE: `DYNAMIC_${et}`, ENTITY_ID: id, COMMENT: text } },
    },
  ];

  let lastErr = null;
  for (const t of tries) {
    try {
      await bitrix.call(t.method, t.params);
      return { ok: true };
    } catch (e) {
      lastErr = e;
    }
  }

  const msg = lastErr?.response?.data?.error_description || lastErr?.message || String(lastErr);
  return { ok: false, error: msg };
}

async function updateItemStagePaid(itemId) {
  const stagePaid = String(cfg.stagePaid || '').trim();
  if (!stagePaid) return { ok: false, error: 'cfg.stagePaid –ø—É—Å—Ç–æ–π (–Ω—É–∂–µ–Ω SPA1048_STAGE_PAID –≤ env)' };

  const r = logInfo('ZIP_FIELD_UPDATE_START', { entityTypeId, itemId, field: F_FILES_PAY_WRITE || F_FILES_PAY_READ });
try {
  let updRes = null;
  try {
    updRes = await bitrix.call('crm.item.update', {

    entityTypeId: cfg.entityTypeId,
    id: Number(itemId),
    fields: {
      stageId: stagePaid,
      ufCrm8SyncAt: nowIso(),
      ufCrm8SyncSrc: 'server_paid_by_checklist',
    },
    });
    const keys = updRes ? Object.keys(updRes) : [];
    logZip('zip-upload-part-ok', { itemId, fid: z.fid, add: fileDatas.length, respKeys: keys.slice(0, 12) });
  } catch (e) {
    const status = e?.status || e?.response?.status || null;
    const data = e?.data || e?.response?.data || null;
    const errCode = data?.error || null;
    const errDesc = data?.error_description || null;
    logZip('zip-upload-part-fail', { itemId, fid: z.fid, add: fileDatas.length, status, errCode, errDesc, msg: String(e?.message||e).slice(0,300) });
    throw e;
  }
  logInfo('ZIP_FIELD_UPDATE_OK', { entityTypeId, itemId });
} catch (err) {
  logError('ZIP_FIELD_UPDATE_FAIL', { entityTypeId, itemId, err: serializeError(err) });
  throw err;
}


  return { ok: true, result: unwrap(r), stagePaid };
}

async function completeTask(taskId) {
  try {
    return { ok: true, result: unwrap(await bitrix.call('tasks.task.complete', { taskId: Number(taskId) })) };
  } catch (e) {
    try {
      return { ok: true, result: unwrap(await bitrix.call('tasks.task.approve', { taskId: Number(taskId) })), fallback: 'tasks.task.approve' };
    } catch (e2) {
      const msg = e2?.response?.data?.error_description || e2?.message || String(e2);
      return { ok: false, error: msg };
    }
  }
}

async function withTempDir(prefix, fn) {
  const dir = await fsp.mkdtemp(path.join(os.tmpdir(), `${prefix}-`));
  try {
    return await fn(dir);
  } finally {
    await fsp.rm(dir, { recursive: true, force: true }).catch(() => {});
  }
}

function looksLikeZipMagic(buf){
  if (!buf || buf.length < 4) return false;
  return buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x03 && buf[3] === 0x04;
}

async function downloadToFile(url, filePath) {
  const res = await axios.get(url, { responseType: 'stream', timeout: 180000, validateStatus: () => true, maxRedirects: 5 });
  if (res.status >= 400) throw new Error(`download failed: ${res.status}`);
  await new Promise((resolve, reject) => {
    const w = fs.createWriteStream(filePath);
    res.data.pipe(w);
    w.on('finish', resolve);
    w.on('error', reject);
  });
}

async function unzipPdfToDir(zipPath, outDir, { maxFiles = ZIP_MAX_FILES } = {}) {
  const out = [];
  let count = 0;

  const stream = fs.createReadStream(zipPath).pipe(unzipper.Parse({ forceStream: true }));
  for await (const entry of stream) {
    const entryName = entry.path || '';
    const base = path.basename(entryName);

    if (entry.type !== 'File') { entry.autodrain(); continue; }

    count += 1;
    if (count > maxFiles) { entry.autodrain(); continue; }

    // 1) –°–Ω–∞—á–∞–ª–∞ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∏–º–µ–Ω–∏ (–¥–µ—à–µ–≤–æ)
    if (!isPdfName(base)) { entry.autodrain(); continue; }

    const dest = path.join(outDir, base);
    await new Promise((resolve, reject) => {
      entry.pipe(fs.createWriteStream(dest))
        .on('finish', resolve)
        .on('error', reject);
    });
    // 2) –î–æ–ø. –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ —Å–∏–≥–Ω–∞—Ç—É—Ä–µ. –í—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è "pdf"-—Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞ –¥–µ–ª–µ –Ω–µ PDF.
    const ok = await isPdfMagicOnDisk(dest);
    if (!ok) {
      await fsp.unlink(dest).catch(() => {});
      continue;
    }
    out.push(dest);
  }

  return out;
}

function chunk(arr, n) {
  const step = Number(n);
  if (!Number.isFinite(step) || step <= 0) return [arr];
  const out = [];
  for (let i = 0; i < arr.length; i += step) out.push(arr.slice(i, i + step));
  return out;
}

function buildUfMultiFilePayload(existingIds, newFileDatas, mode = 'num') {
  const out = [];

  for (const x of (existingIds || [])) {
    const n = Number(x);
    if (!Number.isFinite(n) || n <= 0) continue;
    out.push(mode === 'obj' ? { id: n } : n);
  }

  for (const fd of (newFileDatas || [])) {
    if (!fd) continue;
    const name = fd[0] || 'file.pdf';
    let b64 = String(fd[1] || '');
    b64 = b64.replace(/^data:[^;]+;base64,/, '');
    out.push([name, b64]);
  }

  return out;
}


async function refetchItem(entityTypeId, itemId) {
  const r = await bitrix.call('crm.item.get', { entityTypeId: Number(entityTypeId), id: Number(itemId), select: ['*'] });
  return r?.item || r?.result?.item || r?.result || r;
}

/**
 * –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ ZIP –∏–∑ –ø–æ–ª—è —Ñ–∞–π–ª–æ–≤:
 * - ZIP –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø–æ–ª–µ, –ø–æ–∫–∞ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–º —Ö–æ—Ç—è –±—ã 1 PDF (–ø–æ–ª–µ —É —Ç–µ–±—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ)
 * - PDF –≥—Ä—É–∑–∏–º —á–∞–Ω–∫–∞–º–∏ (–∏–Ω–∞—á–µ —Ç–∞–π–º–∞—É—Ç/–ª–∏–º–∏—Ç—ã)
 * - –ø–æ—Å–ª–µ —É—Å–ø–µ—Ö–∞ —É–¥–∞–ª—è–µ–º ZIP –∏–∑ –ø–æ–ª—è, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ PDF/–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
 */
async function expandZipAttachments({ entityTypeId, itemId, files }) {

  const input = Array.isArray(files) ? files : [];
  if (!input.length) return { changed: false, files: input };

  // 1) –Ω–∞—Ö–æ–¥–∏–º ZIP-—ã
  const zipObjs = [];
  for (const f of input) {
    const fid = normalizeFileToken(f);
    if (!fid) continue;

    let name = '';
    try { name = await resolveFileName(f); } catch (_) { /* ignore */ }

    let isZip = isZipName(name);
    if (!isZip) {
      try {
        const kind = await sniffRemoteKind(f);
        isZip = (kind === 'zip');
      } catch (_) {}
    }

    if (isZip) zipObjs.push({ f, fid, name: name || `file_${fid}.zip` });
  }
  if (!zipObjs.length) return { changed: false, files: input };

  // 2) —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  let currentItem = await refetchItem(entityTypeId, itemId);
  let currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);

  const zipIds = new Set(zipObjs.map((z) => String(Number(z.fid))));
  const beforeIds = new Set(
    (currentFiles || []).map(normalizeFileToken).filter(Boolean).map((x) => String(Number(x)))
  );

  logZip('zip-found', { itemId, zipCount: zipObjs.length, currentCount: currentFiles.length });

  let uploadedTotal = 0;

  // 3) —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ + –∞–ø–ª–æ–∞–¥ PDF
  for (const z of zipObjs) {
    // –ò–Ω–æ–≥–¥–∞ urlMachine –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç ‚Äî –ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ—á–∏—Ç–∞—Ç—å item
    let url = null;
    try {
      url = await resolveFileUrl(z.f, { files: currentFiles });
    } catch (_) {
      url = null;
    }

    if (!url) {
      currentItem = await refetchItem(entityTypeId, itemId);
      currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);
      const afterCount = (currentFiles || []).length;
      logZip('zip-upload-part-after', { itemId, fid: z.fid, beforeCount, afterCount, delta: afterCount - beforeCount });
      if (afterCount <= beforeCount) {
        logZip('zip-upload-part-no-effect', { itemId, fid: z.fid, keep: (keepIds||[]).length, add: (fileDatas||[]).length });
      }
      try {
        url = await resolveFileUrl(z.f, { files: currentFiles });
      } catch (_) {
        url = null;
      }
    }

    if (!url) {
      await addSpaTimelineComment(itemId, `ZIP "${z.name}" –Ω–µ —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.`);
      continue;
    }

    try {
      const { uploaded } = await withTempDir('mpkzip', async (dir) => {
        const zipPath = path.join(dir, z.name || `archive_${z.fid}.zip`);
        const outDir = path.join(dir, 'out');
        await fsp.mkdir(outDir, { recursive: true });

        logZip('zip-download-start', { itemId, fid: z.fid, name: z.name });
        await downloadToFile(url, zipPath);

        const pdfPaths = await unzipPdfToDir(zipPath, outDir, { maxFiles: ZIP_MAX_FILES });
        logZip('zip-unzipped', { itemId, fid: z.fid, pdfCount: pdfPaths.length });

        if (!pdfPaths.length) return { uploaded: 0 };

        const chunkSize = (Number(ZIP_CHUNK) > 0 ? Number(ZIP_CHUNK) : 1);
        const pdfChunks = chunk(pdfPaths, chunkSize);
        logZip('zip-chunks', { itemId, fid: z.fid, pdfCount: (pdfPaths||[]).length, chunkSize, chunks: (pdfChunks||[]).length });
        logZip('zip-chunks', { itemId, fid: z.fid, chunks: pdfChunks.length, chunkSize: ZIP_CHUNK });

        let localUploaded = 0;

        for (let idx = 0; idx < pdfChunks.length; idx++) {
          const part = pdfChunks[idx];

          // –í—Å–µ–≥–¥–∞ –ø–µ—Ä–µ—á–∏—Ç—ã–≤–∞–µ–º ‚Äî —Ç–∞–∫ –º–µ–Ω—å—à–µ —à–∞–Ω—Å–æ–≤ –∑–∞—Ç–µ—Ä–µ—Ç—å —á—É–∂–∏–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∞–ø–¥–µ–π—Ç—ã
          currentItem = await refetchItem(entityTypeId, itemId);
          currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);

          const keepIds = (currentFiles || [])
            .map(normalizeFileToken)
            .filter(Boolean)
            .map((x) => Number(x))
            .filter((n) => Number.isFinite(n) && n > 0);

          const fileDatas = [];
          for (const pdfPath of part) {
            const st = await fsp.stat(pdfPath).catch(() => null);
            if (!st) continue;
            if (st.size > ZIP_MAX_PDF_MB * 1024 * 1024) continue;

            const buf = await fsp.readFile(pdfPath);
            const b64 = buf.toString('base64');
            const fileName = path.basename(pdfPath);
            fileDatas.push([fileName, b64]);
          }

          if (!fileDatas.length) continue;

          const beforeCount = (currentFiles || []).length;

          // crm.item.update –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –ø–æ–ª–µ -> —à–ª—ë–º [—Å—Ç–∞—Ä—ã–µ, –Ω–æ–≤—ã–µ]
          // fallback: –ø—Ä–æ–±—É–µ–º 2 —Ñ–æ—Ä–º–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤
          const tryModes = ['num', 'obj'];

          let applied = false;
          let lastAfterCount = beforeCount;

          for (const mode of tryModes) {
            const payload = buildUfMultiFilePayload(keepIds, fileDatas, mode);

            logZip('zip-upload-part', {
              itemId,
              fid: z.fid,
              name: z.name,
              chunk: idx + 1,
              chunks: pdfChunks.length,
              keep: keepIds.length,
              add: fileDatas.length,
              mode,
            });

            await bitrix.call('crm.item.update', {
              entityTypeId: Number(entityTypeId),
              id: Number(itemId),
              fields: { [F_FILES_PAY_WRITE]: payload },
            });

            currentItem = await refetchItem(entityTypeId, itemId);
            currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);
            lastAfterCount = (currentFiles || []).length;

            logZip('zip-upload-after', {
              itemId,
              fid: z.fid,
              chunk: idx + 1,
              beforeCount,
              afterCount: lastAfterCount,
              addedWanted: fileDatas.length,
              mode,
            });

            if (lastAfterCount > beforeCount) {
              applied = true;
              break;
            }

            logZip('zip-upload-no-effect', { itemId, fid: z.fid, chunk: idx + 1, beforeCount, afterCount: lastAfterCount, mode });
          }

          if (!applied) {
            throw new Error(`crm.item.update: no effect (before=${beforeCount} after=${lastAfterCount})`);
          }

          localUploaded += fileDatas.length;
        }

        return { uploaded: localUploaded };
      });

      uploadedTotal += uploaded;
    } catch (e) {
      const msg = e?.response?.data?.error_description || e?.data?.error_description || e?.message || String(e);
      await addSpaTimelineComment(itemId, `ZIP —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞: –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ PDF –∏–∑ "${z.name}": ${String(msg).slice(0, 220)}. ZIP –æ—Å—Ç–∞–≤–ª–µ–Ω.`);
      logZip('zip-error', { itemId, fid: z.fid, name: z.name, err: String(msg).slice(0, 400) });
      return { changed: false, files: input, error: msg };
    }
  }

  logZip('zip-uploaded-total', { itemId, uploadedTotal, zipFound: zipObjs.length });

  // –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏ ‚Äî ZIP –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
  if (uploadedTotal <= 0) {
    await addSpaTimelineComment(itemId, `ZIP –Ω–∞–π–¥–µ–Ω(—ã): ${zipObjs.length}, –Ω–æ PDF –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏—Å—å (–≤–æ–∑–º–æ–∂–Ω—ã –ª–∏–º–∏—Ç—ã/–ø—Ä–∞–≤–∞). ZIP –æ—Å—Ç–∞–≤–ª–µ–Ω.`);
    return { changed: false, files: input, note: 'no_pdf_uploaded' };
  }

  // 4) –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ PDF ‚Äî —É–¥–∞–ª—è–µ–º ZIP –∏–∑ –ø–æ–ª—è, –æ—Å—Ç–∞–≤–ª—è—è PDF + —Å—Ç–∞—Ä—ã–µ –Ω–µ-PDF
  currentItem = await refetchItem(entityTypeId, itemId);
  currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);

  const finalKeepIds = [];
  for (const f of currentFiles) {
    const fid = normalizeFileToken(f);
    if (!fid) continue;
    const sid = String(Number(fid));
    if (zipIds.has(sid)) continue;

    let name = '';
    try { name = await resolveFileName(f); } catch (_) {}

    // –æ—Å—Ç–∞–≤–ª—è–µ–º PDF + –≤—Å—ë —á—Ç–æ –±—ã–ª–æ –¥–æ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏
    if (isPdfName(name) || beforeIds.has(sid)) finalKeepIds.push(Number(fid));
  }

  if (finalKeepIds.length) {
    logZip('zip-remove', { itemId, before: currentFiles.length, after: finalKeepIds.length, removedZip: zipIds.size });
    await bitrix.call('crm.item.update', {
      entityTypeId: Number(entityTypeId),
      id: Number(itemId),
      fields: { [F_FILES_PAY_WRITE]: finalKeepIds },
    });
  }

  await addSpaTimelineComment(itemId, `ZIP —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω: –¥–æ–±–∞–≤–ª–µ–Ω–æ PDF: ${uploadedTotal}. ZIP —É–¥–∞–ª—ë–Ω –∏–∑ –ø–æ–ª—è.`);
  return { changed: true, files: finalKeepIds };
}


async function syncFilesChecklistAndMaybeClose({ itemId, taskId, item, stageId }) {
  // 1) —Å–Ω–∞—á–∞–ª–∞ ZIP -> PDF (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
  let filesRaw = extractFilesList(item?.[F_FILES_PAY_READ]);

  const zipRes = await expandZipAttachments({
    entityTypeId: cfg.entityTypeId,
    itemId,
    files: filesRaw,
  });

  if (zipRes?.changed) {
    filesRaw = Array.isArray(zipRes.files) ? zipRes.files : filesRaw;
    item = { ...(item || {}), [F_FILES_PAY_READ]: filesRaw };
  }

  // 2) —á–µ–∫–ª–∏—Å—Ç —Å—Ç—Ä–æ–∏–º —Ç–æ–ª—å–∫–æ –ø–æ –ù–ï-ZIP (—Ç–æ –µ—Å—Ç—å –ø–æ PDF –∏ –¥—Ä—É–≥–∏–º —Ñ–∞–π–ª–∞–º)
  const files = extractFilesList(item?.[F_FILES_PAY_READ]);
  const uniqueFiles = files; // –æ–±—ä–µ–∫—Ç—ã (id/urlMachine) —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ –µ—Å—Ç—å

  if (uniqueFiles.length === 0) {
    return { ok: true, files: 0, added: 0, updated: 0, deleted: 0, closed: false, note: 'no_files' };
  }

  const desired = new Map(); // fileId(string) -> title

  for (const f of uniqueFiles) {
    const fid = normalizeFileToken(f);
    if (!fid) continue;

    const name = await resolveFileName(f);
    // detect ZIP even if Bitrix gives random name without extension
    let zipMagic = false;
    try {
      const u = (f && (f.urlMachine || f.url)) ? (f.urlMachine || f.url) : null;
      if (u) {
        const r = await axios.get(u, { responseType: 'arraybuffer', timeout: 60000, validateStatus: () => true });
        const b = Buffer.from(r.data || Buffer.alloc(0));
        zipMagic = looksLikeZipMagic(b.slice(0, 8));
      }
    } catch (e) {}
    logZip('scan-file', { itemId, fid, name, zipMagic });


    // –í –ø–æ–ª–µ –º–æ–≥—É—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è ZIP/–º—É—Å–æ—Ä–Ω—ã–µ —Ñ–∞–π–ª—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∏–∑ –∞—Ä—Ö–∏–≤–∞).
    // –ò–º–µ–Ω–∞ –∏–Ω–æ–≥–¥–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç, –ø–æ—ç—Ç–æ–º—É –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º "–º–∞–≥–∏—é".
    const kind = await sniffRemoteKind(f);
    if (kind === 'zip') continue;
    if (!isPdfName(name) && kind !== 'pdf') continue;

    desired.set(fid, buildChecklistTitle(name, fid));
  }

  if (desired.size === 0) {
    // –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ ZIP –∏–ª–∏ –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–µ —Ñ–∞–π–ª—ã
    return { ok: true, files: 0, added: 0, updated: 0, deleted: 0, closed: false, note: 'no_pdf_files' };
  }

  const existing = await listChecklist(taskId);

  const ours = existing
    .map((x) => {
      const id = x?.ID ?? x?.id;
      const title = x?.TITLE ?? x?.title;
      const isComplete = x?.IS_COMPLETE ?? x?.isComplete;
      const fid = extractMarkerId(title);
      return { id: Number(id), title: String(title || ''), isComplete: String(isComplete || ''), fid };
    })
    .filter((x) => x.id && x.fid);

  const oursByFid = new Map(ours.map((x) => [x.fid, x]));

  let added = 0, updated = 0, deleted = 0;

  for (const x of ours) {
    if (!desired.has(x.fid)) {
      await deleteChecklistItem(taskId, x.id);
      deleted++;
    }
  }

  for (const [fid, title] of desired.entries()) {
    if (!oursByFid.has(fid)) {
      await addChecklistItem(taskId, title);
      added++;
    }
  }

  for (const [fid, title] of desired.entries()) {
    const ex = oursByFid.get(fid);
    if (ex && ex.title !== title) {
      await updateChecklistItem(taskId, ex.id, title);
      updated++;
    }
  }

  const after = await listChecklist(taskId);
  const afterOurs = after
    .map((x) => {
      const id = x?.ID ?? x?.id;
      const title = x?.TITLE ?? x?.title;
      const isComplete = x?.IS_COMPLETE ?? x?.isComplete;
      const fid = extractMarkerId(title);
      return { id: Number(id), title: String(title || ''), isComplete: String(isComplete || ''), fid };
    })
    .filter((x) => x.id && x.fid);

  const relevant = afterOurs.filter((x) => desired.has(x.fid));

  const allDone =
    relevant.length === desired.size &&
    relevant.length > 0 &&
    relevant.every((x) => x.isComplete === 'Y' || x.isComplete === 'true' || x.isComplete === '1');

  let closed = false;
  let closeTaskRes = null;
  let moveRes = null;
  let timeline = null;

  if (allDone) {
    closeTaskRes = await completeTask(taskId);
    moveRes = await updateItemStagePaid(itemId);

    const st = normalizeStageId(stageId);
    const text =
      `–í—Å–µ –ø—É–Ω–∫—Ç—ã —á–µ–∫–ª–∏—Å—Ç–∞ –ø–æ —Ñ–∞–π–ª–∞–º –∑–∞–∫—Ä—ã—Ç—ã. ` +
      `–ó–∞–¥–∞—á–∞ #${taskId} –∑–∞–≤–µ—Ä—à–µ–Ω–∞, —Å—á—ë—Ç –ø–µ—Ä–µ–≤–µ–¥—ë–Ω –≤ "—É—Å–ø–µ—à–Ω–æ –æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ".` +
      (st ? ` (—Å—Ç–∞–¥–∏—è –±—ã–ª–∞: ${st})` : '');

    timeline = await addSpaTimelineComment(itemId, text);
    closed = closeTaskRes?.ok && moveRes?.ok;
  }

  return {
    ok: true,
    files: desired.size,
    added, updated, deleted,
    allDone,
    closed,
    closeTask: closeTaskRes,
    move: moveRes,
    timeline,
  };
}

module.exports = { syncFilesChecklistAndMaybeClose };
