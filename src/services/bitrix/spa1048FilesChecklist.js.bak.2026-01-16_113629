const bitrix = require('./bitrixClient');
const axios = require('axios');
const fs = require('fs');
const fsp = require('fs/promises');
const path = require('path');
const os = require('os');
const unzipper = require('unzipper');
const cfg = require('../../config/spa1048');

// –í crm.item.get UF-—Ñ–∞–π–ª—ã –ø—Ä–∏—Ö–æ–¥—è—Ç –≤ camelCase:
const F_FILES_PAY_READ = process.env.SPA1048_FILES_FIELD_PAY_CAMEL || 'ufCrm8_1768219060503';
// –î–ª—è update –Ω–∞–¥—ë–∂–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è:
const F_FILES_PAY_WRITE = process.env.SPA1048_FILES_FIELD_PAY_ORIG || 'UF_CRM_8_1768219060503';

const ZIP_MAX_FILES = Number(process.env.SPA1048_ZIP_MAX_FILES || 200);
const ZIP_MAX_PDF_MB = Number(process.env.SPA1048_ZIP_MAX_PDF_MB || 15);
const ZIP_CHUNK = Number(process.env.SPA1048_ZIP_CHUNK || 4);

function unwrap(resp) {
  return resp?.result ?? resp;
}

function normalizeStageId(x) {
  if (!x) return '';
  return String(x).trim().replace(/^['"]+|['"]+$/g, '');
}

function nowIso() {
  return new Date().toISOString();
}

function marker(fileId) {
  return `[file:${fileId}]`;
}

function extractMarkerId(title) {
  const m = String(title || '').match(/\[file:(\d+)\]\s*$/);
  return m ? m[1] : null;
}

function fileNameFromContentDisposition(cd) {
  if (!cd) return null;
  const s = String(cd);

  // RFC 5987: filename*=UTF-8''...
  const m1 = s.match(/filename\*\s*=\s*([^;]+)/i);
  if (m1) {
    let v = m1[1].trim();
    v = v.replace(/^UTF-8''/i, '');
    v = v.replace(/^["']|["']$/g, '');
    try { return decodeURIComponent(v); } catch (_e) { return v; }
  }

  // filename="..."
  const m2 = s.match(/filename\s*=\s*("?)([^";]+)\1/i);
  if (m2) return m2[2].trim();

  return null;
}

function normalizeFileToken(x) {
  if (x == null) return null;
  if (typeof x === 'number') return String(x);
  if (typeof x === 'string') {
    const s = x.trim();
    const m = s.match(/(\d+)/);
    return m ? m[1] : null;
  }
  if (typeof x === 'object') {
    if (x.id != null) return normalizeFileToken(x.id);
    if (x.ID != null) return normalizeFileToken(x.ID);
    if (x.fileId != null) return normalizeFileToken(x.fileId);
    if (x.FILE_ID != null) return normalizeFileToken(x.FILE_ID);
    if (x.attachedId != null) return normalizeFileToken(x.attachedId);
  }
  return null;
}

function extractFilesList(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value;
  return [value];
}

async function resolveFileName(fileObjOrId) {
  const fileId = normalizeFileToken(fileObjOrId);
  if (!fileId) return null;

  const urlMachine =
    (fileObjOrId && typeof fileObjOrId === 'object')
      ? (fileObjOrId.urlMachine || fileObjOrId.url_machine || fileObjOrId.url)
      : null;

  if (urlMachine) {
    try {
      // HEAD —á–∞—Å—Ç–æ –∑–∞–ø—Ä–µ—â—ë–Ω ‚Äî fallback –Ω–∞ GET Range
      let resp = null;
      try {
        resp = await axios.head(urlMachine, { maxRedirects: 5, timeout: 20000, validateStatus: () => true });
      } catch (_e) {}

      if (!resp || resp.status >= 400) {
        resp = await axios.get(urlMachine, {
          headers: { Range: 'bytes=0-0' },
          responseType: 'arraybuffer',
          maxRedirects: 5,
          timeout: 20000,
          validateStatus: () => true,
        });
      }

      const cd = resp?.headers?.['content-disposition'] || resp?.headers?.['Content-Disposition'];
      const name = fileNameFromContentDisposition(cd);
      if (name) return String(name);

      const finalUrl = resp?.request?.res?.responseUrl;
      if (finalUrl) {
        const tail = String(finalUrl).split('?')[0].split('/').pop();
        if (tail && tail.includes('.')) return decodeURIComponent(tail);
      }
    } catch (_e2) {}
  }

  return `–§–∞–π–ª #${fileId}`;
}

function isZipName(name) {
  return /\.zip$/i.test(String(name || ''));
}

function isPdfName(name) {
  return /\.pdf$/i.test(String(name || ''));
}

function buildChecklistTitle(fileName, fileId) {
  return `üßæ ${fileName} ${marker(fileId)}`;
}

async function listChecklist(taskId) {
  const r = await bitrix.call('task.checklistitem.getlist', {
    TASKID: Number(taskId),
    ORDER: { ID: 'ASC' },
  });
  const u = unwrap(r);
  return Array.isArray(u) ? u : (Array.isArray(u?.items) ? u.items : []);
}

async function addChecklistItem(taskId, title) {
  return unwrap(await bitrix.call('task.checklistitem.add', {
    TASKID: Number(taskId),
    FIELDS: { TITLE: title, IS_COMPLETE: 'N' },
  }));
}

async function updateChecklistItem(taskId, itemId, title) {
  return unwrap(await bitrix.call('task.checklistitem.update', {
    TASKID: Number(taskId),
    ITEMID: Number(itemId),
    FIELDS: { TITLE: title },
  }));
}

async function deleteChecklistItem(taskId, itemId) {
  return unwrap(await bitrix.call('task.checklistitem.delete', {
    TASKID: Number(taskId),
    ITEMID: Number(itemId),
  }));
}

async function addSpaTimelineComment(itemId, text) {
  return { ok: true, skipped: true };
  const et = Number(cfg.entityTypeId);
  const id = Number(itemId);

  const tries = [
    {
      method: 'crm.timeline.comment.add',
      params: { fields: { ENTITY_TYPE_ID: et, ENTITY_ID: id, COMMENT: text } },
    },
    {
      method: 'crm.timeline.comment.add',
      params: { fields: { ENTITY_TYPE: `DYNAMIC_${et}`, ENTITY_ID: id, COMMENT: text } },
    },
  ];

  let lastErr = null;
  for (const t of tries) {
    try {
      await bitrix.call(t.method, t.params);
      return { ok: true };
    } catch (e) {
      lastErr = e;
    }
  }

  const msg = lastErr?.response?.data?.error_description || lastErr?.message || String(lastErr);
  return { ok: false, error: msg };
}

async function updateItemStagePaid(itemId) {
  const stagePaid = String(cfg.stagePaid || '').trim();
  if (!stagePaid) return { ok: false, error: 'cfg.stagePaid –ø—É—Å—Ç–æ–π (–Ω—É–∂–µ–Ω SPA1048_STAGE_PAID –≤ env)' };

  const r = await bitrix.call('crm.item.update', {
    entityTypeId: cfg.entityTypeId,
    id: Number(itemId),
    fields: {
      stageId: stagePaid,
      ufCrm8SyncAt: nowIso(),
      ufCrm8SyncSrc: 'server_paid_by_checklist',
    },
  });

  return { ok: true, result: unwrap(r), stagePaid };
}

async function completeTask(taskId) {
  try {
    return { ok: true, result: unwrap(await bitrix.call('tasks.task.complete', { taskId: Number(taskId) })) };
  } catch (e) {
    try {
      return { ok: true, result: unwrap(await bitrix.call('tasks.task.approve', { taskId: Number(taskId) })), fallback: 'tasks.task.approve' };
    } catch (e2) {
      const msg = e2?.response?.data?.error_description || e2?.message || String(e2);
      return { ok: false, error: msg };
    }
  }
}

async function withTempDir(prefix, fn) {
  const dir = await fsp.mkdtemp(path.join(os.tmpdir(), `${prefix}-`));
  try {
    return await fn(dir);
  } finally {
    await fsp.rm(dir, { recursive: true, force: true }).catch(() => {});
  }
}

async function downloadToFile(url, filePath) {
  const res = await axios.get(url, { responseType: 'stream', timeout: 180000, validateStatus: () => true, maxRedirects: 5 });
  if (res.status >= 400) throw new Error(`download failed: ${res.status}`);
  await new Promise((resolve, reject) => {
    const w = fs.createWriteStream(filePath);
    res.data.pipe(w);
    w.on('finish', resolve);
    w.on('error', reject);
  });
}

async function unzipPdfToDir(zipPath, outDir, { maxFiles = ZIP_MAX_FILES } = {}) {
  const out = [];
  let count = 0;

  const stream = fs.createReadStream(zipPath).pipe(unzipper.Parse({ forceStream: true }));
  for await (const entry of stream) {
    const entryName = entry.path || '';
    const base = path.basename(entryName);

    if (entry.type !== 'File') { entry.autodrain(); continue; }

    count += 1;
    if (count > maxFiles) { entry.autodrain(); continue; }

    if (!isPdfName(base)) { entry.autodrain(); continue; }

    const dest = path.join(outDir, base);
    await new Promise((resolve, reject) => {
      entry.pipe(fs.createWriteStream(dest))
        .on('finish', resolve)
        .on('error', reject);
    });
    out.push(dest);
  }

  return out;
}

function chunk(arr, n) {
  const out = [];
  for (let i = 0; i < arr.length; i += n) out.push(arr.slice(i, i + n));
  return out;
}

async function refetchItem(entityTypeId, itemId) {
  const r = await bitrix.call('crm.item.get', { entityTypeId: Number(entityTypeId), id: Number(itemId), select: ['*'] });
  return r?.item || r?.result?.item || r?.result || r;
}

/**
 * –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ ZIP –∏–∑ –ø–æ–ª—è —Ñ–∞–π–ª–æ–≤:
 * - ZIP –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ –ø–æ–ª–µ, –ø–æ–∫–∞ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–º —Ö–æ—Ç—è –±—ã 1 PDF (–ø–æ–ª–µ —É —Ç–µ–±—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ)
 * - PDF –≥—Ä—É–∑–∏–º —á–∞–Ω–∫–∞–º–∏ (–∏–Ω–∞—á–µ —Ç–∞–π–º–∞—É—Ç/–ª–∏–º–∏—Ç—ã)
 * - –ø–æ—Å–ª–µ —É—Å–ø–µ—Ö–∞ —É–¥–∞–ª—è–µ–º ZIP –∏–∑ –ø–æ–ª—è, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ PDF/–æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
 */
async function expandZipAttachments({ entityTypeId, itemId, files }) {
  const input = Array.isArray(files) ? files : [];
  if (!input.length) return { changed: false, files: input };

  const zipObjs = [];
  for (const f of input) {
    const fid = normalizeFileToken(f);
    if (!fid) continue;
    const name = await resolveFileName(f);
    if (isZipName(name)) zipObjs.push({ f, fid, name });
  }
  if (!zipObjs.length) return { changed: false, files: input };

  // –¢–µ–∫—É—â–∏–π –Ω–∞–±–æ—Ä id (–≤–∫–ª—é—á–∞—è ZIP) ‚Äî —á—Ç–æ–±—ã –ø–æ–ª–µ –Ω–µ —Å—Ç–∞–ª–æ –ø—É—Å—Ç—ã–º
  let currentItem = await refetchItem(entityTypeId, itemId);
  let currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);

  const zipIds = new Set(zipObjs.map(z => String(z.fid)));

  let uploadedTotal = 0;

  for (const z of zipObjs) {
    const url = z.f?.urlMachine || z.f?.url_machine || z.f?.url;
    if (!url) continue;

    try {
      const { uploaded } = await withTempDir('mpkzip', async (dir) => {
        const zipPath = path.join(dir, z.name || `archive_${z.fid}.zip`);
        const outDir = path.join(dir, 'out');
        await fsp.mkdir(outDir, { recursive: true });

        await downloadToFile(url, zipPath);
        const pdfPaths = await unzipPdfToDir(zipPath, outDir, { maxFiles: ZIP_MAX_FILES });

        if (!pdfPaths.length) return { uploaded: 0 };

        const pdfChunks = chunk(pdfPaths, ZIP_CHUNK);

        let localUploaded = 0;

        for (const part of pdfChunks) {
          // ids —Ç–æ–≥–æ —á—Ç–æ —É–∂–µ –ª–µ–∂–∏—Ç –≤ –ø–æ–ª–µ (–≤–∫–ª—é—á–∞—è ZIP –ø–æ–∫–∞)
          const keepIds = [];
          for (const f of currentFiles) {
            const fid = normalizeFileToken(f);
            if (fid) keepIds.push(Number(fid));
          }

          const fileDatas = [];
          for (const pdfPath of part) {
            const st = await fsp.stat(pdfPath).catch(() => null);
            if (!st) continue;
            if (st.size > ZIP_MAX_PDF_MB * 1024 * 1024) continue;

            const buf = await fsp.readFile(pdfPath);
            const b64 = buf.toString('base64');
            const fileName = path.basename(pdfPath);
            fileDatas.push({ fileData: [fileName, b64] });

          }

          if (!fileDatas.length) continue;

          // –¥–æ–±–∞–≤–ª—è–µ–º PDF (ZIP –æ—Å—Ç–∞—ë—Ç—Å—è, —á—Ç–æ–±—ã –ø–æ–ª–µ –Ω–µ –±—ã–ª–æ –ø—É—Å—Ç—ã–º)
          const beforeIds = new Set(keepIds.map((x) => String(x)));
          await bitrix.call('crm.item.update', {
            entityTypeId: Number(entityTypeId),
            id: Number(itemId),
            fields: { [F_FILES_PAY_WRITE]: [...keepIds, ...fileDatas] },
          });

          // –ø–µ—Ä–µ—á–∏—Ç—ã–≤–∞–µ–º


          currentItem = await refetchItem(entityTypeId, itemId);


          currentFiles = extractFilesList(currentItem?.[F_FILES_PAY_READ]);



          // —Å—á–∏—Ç–∞–µ–º —Ä–µ–∞–ª—å–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ: –Ω–æ–≤—ã–µ fileId, –ø–æ—è–≤–∏–≤—à–∏–µ—Å—è –≤ –ø–æ–ª–µ


          const afterIds = new Set();


          for (const ff of currentFiles) {


            const id = normalizeFileToken(ff);


            if (id) afterIds.add(String(id));


          }


          let diff = 0;


          for (const id of afterIds) { if (!beforeIds.has(id)) diff++; }


          localUploaded += diff;
        }

        return { uploaded: localUploaded };
      });

      uploadedTotal += uploaded;
    } catch (e) {
      const msg = e?.response?.data?.error_description || e?.message || String(e);
      await addSpaTimelineComment(itemId, `ZIP —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞: –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ PDF –∏–∑ "${z.name}": ${String(msg).slice(0, 180)}. ZIP –æ—Å—Ç–∞–≤–ª–µ–Ω.`);
      // –ø—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ ZIP
      return { changed: false, files: input, error: msg };
    }
  }

  // –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏ ‚Äî ZIP –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
  if (uploadedTotal <= 0) {
    await addSpaTimelineComment(itemId, `ZIP –Ω–∞–π–¥–µ–Ω(—ã) (${zipObjs.length}), –Ω–æ PDF –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏—Å—å (–≤–æ–∑–º–æ–∂–Ω—ã –ª–∏–º–∏—Ç—ã/–ø—Ä–∞–≤–∞). ZIP –æ—Å—Ç–∞–≤–ª–µ–Ω.`);
    return { changed: false, files: input, note: 'no_pdf_uploaded' };
  }

  // —Ç–µ–ø–µ—Ä—å —É–¥–∞–ª—è–µ–º ZIP –∏–∑ –ø–æ–ª—è (–æ—Å—Ç–∞–≤–ª—è—è –≤—Å—ë –æ—Å—Ç–∞–ª—å–Ω–æ–µ)
  try {
    const finalIds = [];
    for (const f of currentFiles) {
      const fid = normalizeFileToken(f);
      if (!fid) continue;
      if (zipIds.has(String(fid))) continue; // –≤—ã–∫–∏–¥—ã–≤–∞–µ–º ZIP
      finalIds.push(Number(fid));
    }

    if (finalIds.length > 0) {
      await bitrix.call('crm.item.update', {
        entityTypeId: Number(entityTypeId),
        id: Number(itemId),
        fields: { [F_FILES_PAY_WRITE]: finalIds },
      });
    }

    const finalItem = await refetchItem(entityTypeId, itemId);
    const finalFiles = extractFilesList(finalItem?.[F_FILES_PAY_READ]);

    await addSpaTimelineComment(itemId, `ZIP —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω: –¥–æ–±–∞–≤–ª–µ–Ω–æ PDF (${uploadedTotal}), ZIP —É–¥–∞–ª—ë–Ω (${zipObjs.length}).`);

    return { changed: true, files: finalFiles, removedZip: zipObjs.length, addedPdf: uploadedTotal };
  } catch (e2) {
    const msg = e2?.response?.data?.error_description || e2?.message || String(e2);
    await addSpaTimelineComment(itemId, `PDF –¥–æ–±–∞–≤–ª–µ–Ω—ã (${uploadedTotal}), –Ω–æ —É–¥–∞–ª–∏—Ç—å ZIP –Ω–µ —É–¥–∞–ª–æ—Å—å: ${String(msg).slice(0, 180)}.`);
    const finalItem = await refetchItem(entityTypeId, itemId);
    const finalFiles = extractFilesList(finalItem?.[F_FILES_PAY_READ]);
    return { changed: true, files: finalFiles, removedZip: 0, addedPdf: uploadedTotal, warn: msg };
  }
}

async function syncFilesChecklistAndMaybeClose({ itemId, taskId, item, stageId }) {
  // 1) —Å–Ω–∞—á–∞–ª–∞ ZIP -> PDF (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
  let filesRaw = extractFilesList(item?.[F_FILES_PAY_READ]);

  const zipRes = await expandZipAttachments({
    entityTypeId: cfg.entityTypeId,
    itemId,
    files: filesRaw,
  });

  if (zipRes?.changed) {
    filesRaw = Array.isArray(zipRes.files) ? zipRes.files : filesRaw;
    item = { ...(item || {}), [F_FILES_PAY_READ]: filesRaw };
  }

  // 2) —á–µ–∫–ª–∏—Å—Ç —Å—Ç—Ä–æ–∏–º —Ç–æ–ª—å–∫–æ –ø–æ –ù–ï-ZIP (—Ç–æ –µ—Å—Ç—å –ø–æ PDF –∏ –¥—Ä—É–≥–∏–º —Ñ–∞–π–ª–∞–º)
  const files = extractFilesList(item?.[F_FILES_PAY_READ]);
  const uniqueFiles = files; // –æ–±—ä–µ–∫—Ç—ã (id/urlMachine) —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ –µ—Å—Ç—å

  if (uniqueFiles.length === 0) {
    return { ok: true, files: 0, added: 0, updated: 0, deleted: 0, closed: false, note: 'no_files' };
  }

  const desired = new Map(); // fileId(string) -> title

  for (const f of uniqueFiles) {
    const fid = normalizeFileToken(f);
    if (!fid) continue;

    const name = await resolveFileName(f);
    if (isZipName(name)) continue; // ZIP –Ω–µ –¥–æ–ª–∂–µ–Ω –ø–æ–ø–∞–¥–∞—Ç—å –≤ —á–µ–∫–ª–∏—Å—Ç

    desired.set(fid, buildChecklistTitle(name, fid));
  }

  if (desired.size === 0) {
    // –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ ZIP –∏–ª–∏ –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–µ —Ñ–∞–π–ª—ã
    return { ok: true, files: 0, added: 0, updated: 0, deleted: 0, closed: false, note: 'no_pdf_files' };
  }

  const existing = await listChecklist(taskId);

  const ours = existing
    .map((x) => {
      const id = x?.ID ?? x?.id;
      const title = x?.TITLE ?? x?.title;
      const isComplete = x?.IS_COMPLETE ?? x?.isComplete;
      const fid = extractMarkerId(title);
      return { id: Number(id), title: String(title || ''), isComplete: String(isComplete || ''), fid };
    })
    .filter((x) => x.id && x.fid);

  const oursByFid = new Map(ours.map((x) => [x.fid, x]));

  let added = 0, updated = 0, deleted = 0;

  for (const x of ours) {
    if (!desired.has(x.fid)) {
      await deleteChecklistItem(taskId, x.id);
      deleted++;
    }
  }

  for (const [fid, title] of desired.entries()) {
    if (!oursByFid.has(fid)) {
      await addChecklistItem(taskId, title);
      added++;
    }
  }

  for (const [fid, title] of desired.entries()) {
    const ex = oursByFid.get(fid);
    if (ex && ex.title !== title) {
      await updateChecklistItem(taskId, ex.id, title);
      updated++;
    }
  }

  const after = await listChecklist(taskId);
  const afterOurs = after
    .map((x) => {
      const id = x?.ID ?? x?.id;
      const title = x?.TITLE ?? x?.title;
      const isComplete = x?.IS_COMPLETE ?? x?.isComplete;
      const fid = extractMarkerId(title);
      return { id: Number(id), title: String(title || ''), isComplete: String(isComplete || ''), fid };
    })
    .filter((x) => x.id && x.fid);

  const relevant = afterOurs.filter((x) => desired.has(x.fid));

  const allDone =
    relevant.length === desired.size &&
    relevant.length > 0 &&
    relevant.every((x) => x.isComplete === 'Y' || x.isComplete === 'true' || x.isComplete === '1');

  let closed = false;
  let closeTaskRes = null;
  let moveRes = null;
  let timeline = null;

  if (allDone) {
    closeTaskRes = await completeTask(taskId);
    moveRes = await updateItemStagePaid(itemId);

    const st = normalizeStageId(stageId);
    const text =
      `–í—Å–µ –ø—É–Ω–∫—Ç—ã —á–µ–∫–ª–∏—Å—Ç–∞ –ø–æ —Ñ–∞–π–ª–∞–º –∑–∞–∫—Ä—ã—Ç—ã. ` +
      `–ó–∞–¥–∞—á–∞ #${taskId} –∑–∞–≤–µ—Ä—à–µ–Ω–∞, —Å—á—ë—Ç –ø–µ—Ä–µ–≤–µ–¥—ë–Ω –≤ "—É—Å–ø–µ—à–Ω–æ –æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ".` +
      (st ? ` (—Å—Ç–∞–¥–∏—è –±—ã–ª–∞: ${st})` : '');

    timeline = await addSpaTimelineComment(itemId, text);
    closed = closeTaskRes?.ok && moveRes?.ok;
  }

  return {
    ok: true,
    files: desired.size,
    added, updated, deleted,
    allDone,
    closed,
    closeTask: closeTaskRes,
    move: moveRes,
    timeline,
  };
}

module.exports = { syncFilesChecklistAndMaybeClose };
